<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Hoohah-Coster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <meta name="theme-color" content="#020308">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 20%, #182848 0%, #060814 45%, #020308 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f8fafc;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 22px;
    }

    #settings {
      position: absolute;
      top: 60px;
      right: 20px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 12px 16px;
      border-radius: 16px;
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s;
      z-index: 10;
      min-width: 280px;
      font-size: 14px;
    }

    #phaseListUI {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 300px;
      overflow-y: auto;
    }

    .phase-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      transition: transform 0.15s ease, border 0.15s ease, background 0.15s ease, opacity 0.15s ease;
      border: 1px solid transparent;
    }

    .phase-header {
      cursor: pointer;
      opacity: 0.85;
    }

    .phase-row.dragging {
      opacity: 0.6;
      transform: scale(0.99);
      background: rgba(148, 163, 184, 0.12);
      border-color: rgba(94, 234, 212, 0.5);
    }

    .phase-row.drag-over {
      border-color: rgba(14, 165, 233, 0.7);
      background: rgba(14, 165, 233, 0.08);
    }

    .phase-controls {
      width: 100%;
      margin-top: 6px;
      height: 0;
      overflow: hidden;
      transition: height .3s ease, opacity .3s ease, padding .3s ease;
      opacity: 0;
      padding: 0 4px;
    }

    .phase-controls.open {
      height: auto;
      opacity: 1;
      padding: 8px 4px;
    }

    .phase-controls .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .phase-controls label {
      font-size: 12px;
      width: 90px;
      color: #cbd5e1;
    }

    #toggleSettings {
      position: absolute;
      top: 18px;
      right: 18px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
      color: #fff;
      padding: 10px 14px;
      border-radius: 14px;
      cursor: pointer;
      z-index: 11;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    #phaseActions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 12px;
    }

    #phaseActions button {
      padding: 8px 12px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      font-size: 13px;
    }

    #addPhase {
      background: #1e293b;
      color: white;
    }

    #savePattern {
      background: #0ea5e9;
      color: white;
    }

    .icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      padding: 6px;
      cursor: pointer;
      color: inherit;
    }

    .icon {
      width: 18px;
      height: 18px;
      display: block;
    }

    .drag-icon {
      width: 18px;
      height: 18px;
      cursor: grab;
      opacity: 0.7;
    }

    @media (max-width: 800px) {
      body {
        padding: 10px;
      }

      canvas {
        border-radius: 16px;
      }

      #toggleSettings {
        top: 12px;
        right: 12px;
        font-size: 15px;
        padding: 12px 15px;
      }

      #settings {
        top: auto;
        right: 12px;
        left: 12px;
        bottom: 12px;
        min-width: auto;
        width: auto;
        font-size: 15px;
        padding: 14px 16px;
        border-radius: 18px;
        max-height: 70vh;
        overflow-y: auto;
      }

      #phaseListUI {
        max-height: none;
      }

      .phase-row {
        padding: 10px;
      }

      .phase-controls label {
        width: 100px;
        font-size: 13px;
      }

      #phaseActions {
        justify-content: center;
      }

      #phaseActions button {
        font-size: 14px;
        padding: 10px 14px;
      }
    }
  </style>
</head>
<body>
  <canvas id="breathCanvas"></canvas>

  <div id="settings">
    <div id="phaseListUI"></div>
    <div id="options" style="display:flex;align-items:center;gap:8px;margin:8px 0 4px;">
      <label for="easeMode" style="font-size:12px;color:#e2e8f0;cursor:pointer;">Ease mode</label>
      <select id="easeMode" style="flex:1;background:#0f172a;color:#e2e8f0;border:1px solid rgba(255,255,255,0.15);border-radius:8px;padding:6px 8px;font-size:12px;">
        <option value="off">Off</option>
        <option value="line">Line</option>
        <option value="screen">Screen</option>
      </select>
    </div>
    <div id="timeControls" style="display:flex;align-items:center;gap:10px;margin:6px 0 6px;">
      <label for="timeScale" style="font-size:12px;color:#e2e8f0;cursor:pointer;">시간 구간</label>
      <input id="timeScale" type="range" min="0.5" max="2" step="0.1" value="1" style="flex:1;">
      <span id="timeScaleValue" style="width:48px;text-align:right;font-size:12px;color:#cbd5e1;">1.0x</span>
    </div>
    <div id="phaseActions">
      <button id="addPhase">+ Add phase</button>
      <button id="savePattern">Save</button>
    </div>
  </div>

  <button id="toggleSettings">Settings</button>

  <script>
    (() => {
      const canvas = document.getElementById("breathCanvas");
      const ctx = canvas.getContext("2d");
      const ACCENT = "#f6b132"; // deeper amber to avoid pale look on iOS
      const ACCENT_SHADOW = "rgba(246, 177, 50, 0.9)";

      const settings = document.getElementById("settings");
      const phaseListUI = document.getElementById("phaseListUI");
      const easeModeSelect = document.getElementById("easeMode");
      const toggleSettingsBtn = document.getElementById("toggleSettings");
      const addPhaseBtn = document.getElementById("addPhase");
      const savePatternBtn = document.getElementById("savePattern");
      const timeScaleInput = document.getElementById("timeScale");
      const timeScaleValue = document.getElementById("timeScaleValue");
      const ICONS = {
        settings: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${ACCENT}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c0 .69.4 1.31 1.02 1.59.29.14.62.21.98.21H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1Z"/></svg>`,
        drag: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#cbd5e1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 5h.01M15 5h.01M9 12h.01M15 12h.01M9 19h.01M15 19h.01"/></svg>`,
        delete: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#f87171" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6v14a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg>`
      };
      const iconUrl = (name) => "data:image/svg+xml," + encodeURIComponent(ICONS[name]);

      const dpr = window.devicePixelRatio || 1;
      const glowFactor = Math.max(1, dpr);
      let width = 0;
      let height = 0;

      // Base phases (level 0-1, duration in seconds)
      let pattern = [
        { level: 0.0, duration: 0 },  // hidden anchor at 0%
        { level: 1.0, duration: 4 },  // inhale to 100% (4s)
        { level: 1.0, duration: 7 },  // hold (7s)
        { level: 0.1, duration: 8 },  // exhale to 10% (8s)
        { level: 0.1, duration: 2 }   // hold (2s)
      ];

      let easeMode = "off"; // 'off', 'line', or 'screen'
      let timeZoom = 1; // >1 shows a longer time window (slower px/sec)

      // Load saved pattern if it exists
      const saved = localStorage.getItem("breathPattern");
      const savedEase = localStorage.getItem("breathEaseMode");
      const savedTimeZoom = localStorage.getItem("breathTimeZoom");
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          if (Array.isArray(parsed) && parsed.length >= 2) {
            pattern = parsed;
          }
        } catch (e) {
          console.warn("Saved pattern parse error", e);
        }
      }
      if (savedEase !== null) {
        easeMode = savedEase;
      }
      if (savedTimeZoom !== null) {
        const parsedZoom = parseFloat(savedTimeZoom);
        if (!Number.isNaN(parsedZoom)) {
          timeZoom = Math.min(2, Math.max(0.5, parsedZoom));
        }
      }

      // Ensure leading anchor exists
      if (!pattern.length || pattern[0].duration !== 0) {
        pattern.unshift({ level: 0, duration: 0 });
      }

      const getPeriod = () => pattern.reduce((acc, p) => acc + (p.duration || 0), 0);
      let PERIOD = getPeriod();

      let baseFlowSpeed = 60;
      const getEffectiveFlowSpeed = () => baseFlowSpeed / timeZoom;
      const minLevel = 0.10;
      const maxLevel = 0.90;
      const padding = 20;

      let startTime = null;
      let lastTs = null;
      let viewTime = 0; // time used for rendering (can run faster/slower in screen mode)

      function updateAnchor() {
        if (!pattern.length) return;
        const last = pattern[pattern.length - 1];
        pattern[0].level = last ? last.level : 0;
        pattern[0].duration = 0;
      }
      updateAnchor();

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // Show a longer time window on smaller screens by reducing px/sec
        baseFlowSpeed = window.innerWidth <= 800 ? 35 : 60;
      }

      window.addEventListener("resize", resize);
      resize();
      updateTimeScaleUI();

      // Toggle fullscreen on canvas double-click (double-click again or press Esc to exit)
      function toggleFullscreen() {
        if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen().catch(() => {});
        } else if (document.fullscreenElement && document.exitFullscreen) {
          document.exitFullscreen().catch(() => {});
        }
      }
      canvas.addEventListener("dblclick", toggleFullscreen);

      // Close settings when clicking outside (and avoid toggling fullscreen)
      document.addEventListener("click", (e) => {
        const clickedInsideSettings = settings.contains(e.target);
        const clickedToggleBtn = toggleSettingsBtn.contains(e.target);
        if (!clickedInsideSettings && !clickedToggleBtn) {
          settings.style.opacity = "0";
          settings.style.pointerEvents = "none";
        }
      });

      function getPhaseIndexAndProgress(t) {
        if (pattern.length < 2) {
          return { index: 0, progress: 0 };
        }
        const period = PERIOD || 1;
        let timeline = t % period;
        if (timeline < 0) timeline += period;

        let acc = 0;
        for (let i = 0; i < pattern.length - 1; i++) {
          const nextPhase = pattern[i + 1];
          const segDuration = nextPhase ? nextPhase.duration : 0;
          if (timeline <= acc + segDuration) {
            const local = timeline - acc;
            const progress = segDuration > 0 ? local / segDuration : 0;
            return { index: i, progress };
          }
          acc += segDuration;
        }
        return { index: pattern.length - 2, progress: 1 };
      }

      function getBreathLevel(t) {
        const { index, progress } = getPhaseIndexAndProgress(t);
        const safeIndex = Math.max(0, Math.min(index, pattern.length - 2));
        const curr = pattern[safeIndex];
        const next = pattern[safeIndex + 1] || curr;
        const easeOut = (x) => 1 - Math.pow(1 - x, 3); // quicker start, slower finish
        const easedProgress =
          easeMode === "line" ? easeOut(progress) :
          easeMode === "screen" ? progress :
          progress;
        const rawLevel = curr.level + (next.level - curr.level) * easedProgress;
        return minLevel + (maxLevel - minLevel) * rawLevel;
      }

      function movePhase(from, to) {
        // anchor stays at index 0
        if (from < 1 || to < 1) return;
        if (from === to) return;
        const [item] = pattern.splice(from, 1);
        const target = Math.max(1, Math.min(to, pattern.length));
        pattern.splice(target, 0, item);
        updateAnchor();
        PERIOD = getPeriod();
      }

      function drawBackground(t) {
        const level = getBreathLevel(t);
        const eased = 0.5 - Math.cos(level * Math.PI) * 0.5;
        const base = 6; // darker
        const blue = 22 + eased * 28;
        const green = 10 + eased * 18;
        const wobbleX = Math.sin(t * 0.25) * 8;
        const wobbleY = Math.cos(t * 0.22) * 6;
        const midStop = 52 + Math.sin(t * 0.3) * 4;
        const center = `rgb(${base}, ${green}, ${blue})`;
        document.body.style.background =
          `radial-gradient(circle at ${50 + wobbleX}% ${50 + wobbleY}%, ${center}, #0b1d42 ${midStop}%, #02030c 100%)`;
      }

      function getFlowSpeed(t) {
        const base = getEffectiveFlowSpeed();
        if (easeMode !== "screen") return base;
        const { progress } = getPhaseIndexAndProgress(t);
        // If level is held (no change), keep base speed
        const { index } = getPhaseIndexAndProgress(t);
        const curr = pattern[Math.max(0, Math.min(index, pattern.length - 2))];
        const next = pattern[Math.max(0, Math.min(index + 1, pattern.length - 1))];
        if (curr && next && curr.level === next.level) return base;
        const easeOut = (x) => 1 - Math.pow(1 - x, 3); // fast start, slow end
        const eased = easeOut(progress);
        // more pronounced variation: start ~1.8x speed, end ~0.45x speed
        const minFactor = 0.45;
        const maxFactor = 1.8;
        const factor = minFactor + (1 - eased) * (maxFactor - minFactor);
        return base * factor;
      }

      function drawBreathLine(t) {
        const centerX = width / 2;
        const usableHeight = height - padding * 2;
        // keep shape stable; only center time advances faster/slower
        const pxPerSec = getEffectiveFlowSpeed();

        ctx.save();
        ctx.globalCompositeOperation = "source-over";
        ctx.beginPath();
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        for (let x = 0; x <= centerX; x += 2) {
          const timeAtX = t + (x - centerX) / pxPerSec;
          const level = getBreathLevel(timeAtX);
          const y = height - padding - level * usableHeight;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = ACCENT;
        ctx.lineWidth = 8;
        ctx.shadowBlur = 18 * glowFactor * 1.2;
        ctx.shadowColor = ACCENT_SHADOW;
        ctx.stroke();

        ctx.beginPath();
        for (let x = centerX; x <= width; x += 2) {
          const timeAtX = t + (x - centerX) / pxPerSec;
          const level = getBreathLevel(timeAtX);
          const y = height - padding - level * usableHeight;
          if (x === centerX) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = "rgba(200,200,200,0.35)";
        ctx.lineWidth = 6;
        ctx.shadowBlur = 0;
        ctx.stroke();
        ctx.restore();
      }

      function drawCenterBall(t) {
        const level = getBreathLevel(t);
        const usableHeight = height - padding * 2;
        const y = height - padding - level * usableHeight;
        const centerX = width / 2;
        // Radius follows breath level and a faster micro-pulse
        const baseRadius = 16 + level * 10;
        const microPulse = Math.sin(t * Math.PI * 1.2) * 1.5; // slower, gentler pulse
        const radius = Math.max(10, baseRadius + microPulse);

        ctx.save();
        ctx.globalCompositeOperation = "source-over";
        ctx.beginPath();
        ctx.arc(centerX, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = ACCENT;
        ctx.shadowBlur = 25 * glowFactor * 1.2;
        ctx.shadowColor = ACCENT_SHADOW;
        ctx.fill();
        ctx.restore();
      }

      let lastPhaseIndex = null;
      function hapticOnPhaseChange(t) {
        if (!navigator.vibrate) return;
        const { index } = getPhaseIndexAndProgress(t);
        if (index !== lastPhaseIndex) {
          navigator.vibrate(50);
          lastPhaseIndex = index;
        }
      }

      function updateTimeScaleUI() {
        if (!timeScaleInput || !timeScaleValue) return;
        timeScaleInput.value = String(timeZoom);
        timeScaleValue.textContent = `${timeZoom.toFixed(1)}x`;
      }

      function renderPhaseList() {
        phaseListUI.innerHTML = "";

        // skip anchor (index 0), show only destination phases
        pattern.slice(1).forEach((p, idx) => {
          const i = idx + 1; // actual index in pattern
          const row = document.createElement("div");
          row.className = "phase-row";
          row.dataset.patternIndex = String(i);

          const header = document.createElement("div");
          header.className = "phase-header";
          header.style.flex = "1";
          const setHeader = () => {
            header.textContent = `#${idx + 1} • Level ${(p.level * 100).toFixed(0)}% / ${p.duration}s`;
          };
          setHeader();

          const controls = document.createElement("div");
          controls.className = "phase-controls";

          header.addEventListener("click", () => {
            const isOpen = controls.classList.contains("open");
            if (isOpen) {
              controls.classList.remove("open");
              controls.style.maxHeight = "0";
            } else {
              controls.classList.add("open");
              controls.style.maxHeight = "220px";
            }
          });

          const topRow = document.createElement("div");
          topRow.style.display = "flex";
          topRow.style.alignItems = "center";
          topRow.style.gap = "10px";
          topRow.style.width = "100%";

      const dragHandle = document.createElement("img");
      dragHandle.src = iconUrl("drag");
      dragHandle.alt = "Drag to reorder";
      dragHandle.className = "drag-icon";
      dragHandle.draggable = true;

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "icon-button";
          const deleteIcon = document.createElement("img");
          deleteIcon.src = iconUrl("delete");
          deleteIcon.alt = "Delete phase";
          deleteIcon.className = "icon";
          deleteBtn.appendChild(deleteIcon);

          deleteBtn.addEventListener("click", () => {
            // keep anchor + at least one destination
            if (pattern.length > 2) {
              pattern.splice(i, 1);
              updateAnchor();
              PERIOD = getPeriod();
              renderPhaseList();
            }
          });

          const levelRow = document.createElement("div");
          levelRow.className = "row";
          const levelLabel = document.createElement("label");
          levelLabel.textContent = "Level";
          const levelInput = document.createElement("input");
          levelInput.type = "range";
          levelInput.min = "0";
          levelInput.max = "1";
          levelInput.step = "0.05";
          levelInput.value = String(p.level);
          levelInput.style.flex = "1";
          levelInput.addEventListener("input", () => {
            p.level = parseFloat(levelInput.value);
            setHeader();
            updateAnchor();
          });
          levelRow.appendChild(levelLabel);
          levelRow.appendChild(levelInput);

          const durationRow = document.createElement("div");
          durationRow.className = "row";
          const durationLabel = document.createElement("label");
          durationLabel.textContent = "Duration (s)";
          const durationInput = document.createElement("input");
          durationInput.type = "number";
          durationInput.min = "0";
          durationInput.value = String(p.duration);
          durationInput.style.flex = "1";
          durationInput.addEventListener("input", () => {
            p.duration = Math.max(0, parseFloat(durationInput.value) || 0);
            PERIOD = getPeriod();
            setHeader();
            updateAnchor();
          });
          durationRow.appendChild(durationLabel);
          durationRow.appendChild(durationInput);

          topRow.appendChild(dragHandle);
          topRow.appendChild(header);
          topRow.appendChild(deleteBtn);

          controls.appendChild(levelRow);
          controls.appendChild(durationRow);

          row.appendChild(topRow);
          row.appendChild(controls);
          phaseListUI.appendChild(row);

          dragHandle.addEventListener("dragstart", (e) => {
            row.classList.add("dragging");
            if (e.dataTransfer) {
              e.dataTransfer.effectAllowed = "move";
              e.dataTransfer.setData("text/plain", row.dataset.patternIndex || "");
            }
          });

          dragHandle.addEventListener("dragend", () => {
            row.classList.remove("dragging");
          });

          row.addEventListener("dragover", (e) => {
            e.preventDefault();
            row.classList.add("drag-over");
            if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
          });

          row.addEventListener("drop", (e) => {
            e.preventDefault();
            const from = parseInt((e.dataTransfer && e.dataTransfer.getData("text/plain")) || "-1", 10);
            const to = parseInt(row.dataset.patternIndex || "-1", 10);
            row.classList.remove("drag-over");
            if (!Number.isNaN(from) && !Number.isNaN(to)) {
              movePhase(from, to);
              renderPhaseList();
            }
          });

          row.addEventListener("dragleave", () => {
            row.classList.remove("drag-over");
          });
        });
      }

      function animate(ts) {
        if (!startTime) {
          startTime = ts;
          lastTs = ts;
          viewTime = 0;
        }
        const dt = (ts - lastTs) / 1000;
        lastTs = ts;

        const baseT = (ts - startTime) / 1000;
        const baseSpeed = getEffectiveFlowSpeed();
        if (easeMode === "screen") {
          const flowSpeed = getFlowSpeed(viewTime);
          const timeScale = flowSpeed / baseSpeed;
          viewTime += dt * timeScale;
        } else {
          viewTime = baseT;
        }

        ctx.clearRect(0, 0, width, height);
        drawBackground(viewTime);
        drawBreathLine(viewTime);
        drawCenterBall(viewTime);
        hapticOnPhaseChange(viewTime);

        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);

      toggleSettingsBtn.setAttribute("aria-label", "Settings");
      toggleSettingsBtn.textContent = "";
      const settingsIcon = document.createElement("img");
      settingsIcon.src = iconUrl("settings");
      settingsIcon.alt = "";
      settingsIcon.className = "icon";
      toggleSettingsBtn.appendChild(settingsIcon);

      toggleSettingsBtn.addEventListener("click", () => {
        const hidden = settings.style.opacity === "0" || settings.style.opacity === "";
        settings.style.opacity = hidden ? "1" : "0";
        settings.style.pointerEvents = hidden ? "auto" : "none";

        if (hidden) {
          easeModeSelect.value = easeMode;
          renderPhaseList();
          updateTimeScaleUI();
        }
      });

      addPhaseBtn.addEventListener("click", () => {
        const last = pattern[pattern.length - 1];
        pattern.push({ level: last.level, duration: 4 });
        updateAnchor();
        PERIOD = getPeriod();
        renderPhaseList();
      });

      easeModeSelect.addEventListener("change", () => {
        easeMode = easeModeSelect.value;
        localStorage.setItem("breathEaseMode", easeMode);
      });

      timeScaleInput.addEventListener("input", () => {
        timeZoom = Math.min(2, Math.max(0.5, parseFloat(timeScaleInput.value) || 1));
        updateTimeScaleUI();
      });

      timeScaleInput.addEventListener("change", () => {
        localStorage.setItem("breathTimeZoom", String(timeZoom));
      });

      savePatternBtn.addEventListener("click", () => {
        localStorage.setItem("breathPattern", JSON.stringify(pattern));
        settings.style.opacity = "0";
        settings.style.pointerEvents = "none";
      });
    })();
  </script>
</body>
</html>
